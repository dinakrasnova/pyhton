#args and kwargs

def is_cat_here(*args):
    if 'cats' in args:
        return True
    else:
        return False
    
print(is_cat_here('cats is here'))

def is_item_here(item,*args):
    if item in args:
        return True
    else:
        return False
    
print(is_item_here(1, 1234))

def your_favorite_color(my_color, **kwargs): 
    if 'color' in kwargs:
        print('My favorite color is ' + my_color + ', but {} is also pretty good!'.format(kwargs['color']))
    else:
        print('My favorite color is ' + my_color + ' , what is your favorite color?')
        
your_favorite_color('green', name = 'Jane')
your_favorite_color('green', name = 'Jane', color = 'red')

#Классы Создайте класс BlogPost с атрибутами user_name, text, number_of_likes. Создайте два объекта этого класса. После создания измените атрибут number_of_likes одного из объектов. Распечатайте атрибут number_of_likes каждого из объектов

#Мое решение

class BlogPost:
    def __init__(self, user_name, text, number_of_likes):
        self.user_name = user_name
        self.text = text
        self.number_of_likes = number_of_likes
    
    def changenumber_of_likes(self,newnumber_of_likes):
        self.number_of_likes = newnumber_of_likes

user_John = BlogPost(user_name = 'John', text = 'hi', number_of_likes = 4)
user_Jane = BlogPost(user_name = 'Jane', text = 'hello', number_of_likes = 5)

print(user_John.number_of_likes)
print(user_Jane.number_of_likes)

    
user_John.changenumber_of_likes(6)

print(user_John.number_of_likes)

#Ответ

class BlogPost:
    def __init__(self, user_name, text, number_of_likes):
        self.user_name = user_name
        self.text = text
        self.number_of_likes = number_of_likes


post_about_politicians = BlogPost('John', 'I like politicians', 0)
post_about_cats = BlogPost('Jane', 'I like cats', 0)

post_about_cats.number_of_likes = 1000

print(post_about_politicians.number_of_likes)
print(post_about_cats.number_of_likes)

#Методы Создайте класс BankAccount с атрибутами client_id, client_first_name, client_last_name, balance и методами add() и withdraw(), при помощи которых можно пополнять счет и выводить средства со счета соответственно. Атрибут balance должен инициализироваться по умолчанию значением 0.0 и меняться при срабатывании методов add() и withdraw().

class BankAccount:
    def __init__(self, client_id, client_first_name, client_last_name, balance = 0.0):
        self.client_id = client_id
        self.client_first_name = client_first_name
        self.client_last_name = client_last_name
        self.balance = balance
        
 
    def add(self, n):
        self.balance += n
 
    def withdraw(self, n):
        self.balance -= n
 
    def print_balance (self):
        print('%.2f' % self.balance)
        
        
   #Ответ
   
   class BankAccount:

    def __init__(self, client_id, client_first_name,
                 client_last_name):
        self.client_id = client_id
        self.client_first_name = client_first_name
        self.client_last_name = client_last_name
        self.balance = 0.0

    def add(self, amount):
        self.balance += amount

    def withdraw(self, amount):
        self.balance -= amount


account_1 = BankAccount(1, 'John', 'Brown')
account_2 = BankAccount(2, 'Jim', 'White')

account_1.add(1000)
print(account_1.balance)
account_1.withdraw(500)
print(account_1.balance)
print(account_2.balance)

#Наследование и полиморфизм Создайте класс GameCharacter с атрибутами name, health, level и методом speak(), который выводит на печать 'Hi, my name is (значение атрибута name)'.

#Создайте класс Villain, наследник класса GameCharacter с теми же атрибутами, методом speak(), который выводит на печать 'Hi, my name is (значение атрибута name) and I will kill you', методом kill(), который принимает в качестве параметра объект класса GameCharacter, присваивает атрибуту health этого объекта значение 0 и  выводит на печать 'Bang-bang, now you're dead'

class GameCharacter:

    def __init__(self, name, health,
                 level):
        self.name = name
        self.health = health
        self.level = level

    def speak(self):
        print('Hi, my name is ' + self.name)


class Villain(GameCharacter):
    
    def __init__(self, name, health, level):
        self.name = name
        self.health = health
        self.level = level
    
    def speak(self):
        print('Hi, my name is ' + self.name + 'I will kill you')



    def kill(self, other):
        other.health = 0
        print('Bang-bang, now you\'re dead')


james = GameCharacter('James', 100, 1)
jim = Villain('Jim', 100, 2)

james.speak()
jim.speak()
print(james.health)
jim.kill(james)
print(james.health)

#Создайте класс Chain с атрибутом number_of_items.

#Создайте два специальных метода в этом классе.

#Первый должен при вызове встроенной функции print() для объекта этого класса выводить 'Chain with (значение number_of_items) items'

#Второй должен при вызове встроенной функции len() для объекта этого класса возвращать значение number_of_items этого объекта

class Chain:
    def __init__(self, number_of_items):
        self.number_of_items = number_of_items
    
    def printing(self):
        print('Chain with ' + self.number_of_items + ' items')
    
    def len_(self):
        return len(self.number_of_items)
        
two = Chain('2')
two.printing()
print(two.len_())

class Chain():
    def __init__(self, number_of_items):
        self.number_of_items = number_of_items

    def __str__(self):
        return "Chain with " + str(self.number_of_items)

    def __len__(self):
        return self.number_of_items


chain_1 = Chain(23)
chain_2 = Chain(32)

print(chain_1)
print(chain_2)

#Создайте функцию-генератор get_week_day(), которая создаёт генератор, вырабатывающий один день недели за раз, Дни недели должны начинаться с воскресенья и заканчиваться субботой.

#current_day = get_week_day()

#print(current_day.__next__()) # 'Sunday'

#print(current_day.__next__()) # 'Monday'

#print(current_day.__next__()) # 'Tuesday'

#print(current_day.__next__()) # 'Wednesday'

#print(current_day.__next__()) # 'Thursday'

#print(current_day.__next__()) # 'Friday'

#print(current_day.__next__()) # 'Saturday'

def get_week_day():
    days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
    for day in days:
        yield day
        
current_day = get_week_day()

print(current_day.__next__())
print(current_day.__next__())

#Создайте функцию even_odd(), создающую генератор, который будет попеременно вырабатывать строки 'even' и 'odd'.

#even_odd_generator = even_odd()

#print(next(even_odd_generator)) # 'even'

#print(next(even_odd_generator)) # 'odd'

def even_odd():
    value = 'even'
    while True:
        yield value
        if value == 'even':
            value = "odd"
        else:
            value = "even"
 #Создайте функцию, возвращающую генератор, бесконечно вырабатывающий квадраты целых чисел, начиная с 1.

#infinite_square_generator = get_infinite_square_generator()

#print(next(infinite_square_generator)) # 1 

def get_infinite_square_generator():
    number = 1
    while True:
        yield number * number
        number += 1
infinite_square_generator = get_infinite_square_generator()
print(next(infinite_square_generator))
print(next(infinite_square_generator))


#Создайте функцию-декоратор print_args, которая распечатывает аргументы *args и **kwargs функции, которую она декорирует

from functools import wraps


def print_args(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print("args:", args)
        print("kwargs:", kwargs)
        return func(*args, **kwargs)
    return wrapper


@print_args
def some_func():
    print('Some code')


some_func()
